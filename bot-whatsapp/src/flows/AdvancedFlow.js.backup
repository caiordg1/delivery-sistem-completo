// src/flows/advancedFlow.js
// Fluxo Avan√ßado Completo para Processamento de Pedidos

const StateManager = require('../services/StateManager');
const ValidationService = require('../services/ValidationService');

class AdvancedFlow {
    constructor() {
        this.stateManager = new StateManager();
        
        console.log('[AdvancedFlow] Iniciado com sucesso');
    }

    // Processa mensagem baseada no estado atual do usu√°rio
    async processMessage(sock, chatId, message, userPhone) {
        try {
            const currentState = this.stateManager.getState(userPhone);
            const userData = this.stateManager.getUserData(userPhone);
            
            console.log(`[AdvancedFlow] ${userPhone} | Estado: ${currentState} | Mensagem: ${message.substring(0, 30)}`);

            // Comandos globais (funcionam em qualquer estado)
            if (this.handleGlobalCommands(sock, chatId, message, userPhone)) {
                return true;
            }

            // Processar baseado no estado atual
            switch (currentState) {
                case StateManager.STATES.CONFIRMING_ORDER:
                    return await this.handleOrderConfirmation(sock, chatId, message, userPhone, userData);
                
                case StateManager.STATES.COLLECTING_NAME:
                    return await this.handleNameCollection(sock, chatId, message, userPhone);
                
                case StateManager.STATES.COLLECTING_EMAIL:
                    return await this.handleEmailCollection(sock, chatId, message, userPhone);
                
                case StateManager.STATES.COLLECTING_ADDRESS:
                    return await this.handleAddressCollection(sock, chatId, message, userPhone);
                
                case StateManager.STATES.SELECTING_PAYMENT:
                    return await this.handlePaymentSelection(sock, chatId, message, userPhone, userData);
                
                case StateManager.STATES.WAITING_PAYMENT:
                    return await this.handlePaymentWaiting(sock, chatId, message, userPhone, userData);
                
                default:
                    return false; // N√£o est√° em fluxo ativo
            }

        } catch (error) {
            console.error('[AdvancedFlow] Erro:', error);
            await sock.sendMessage(chatId, { 
                text: "‚ùå Ocorreu um erro. Digite *cancelar* para recome√ßar." 
            });
            return true;
        }
    }

    // Comandos globais (cancelar, ajuda, etc)
    handleGlobalCommands(sock, chatId, message, userPhone) {
        const lowerMessage = message.toLowerCase().trim();
        
        if (['cancelar', 'cancel', 'sair', 'pare', 'parar'].includes(lowerMessage)) {
            this.stateManager.resetSession(userPhone);
            sock.sendMessage(chatId, { 
                text: "‚ùå *Pedido cancelado!*\n\nDigite *menu* para ver nosso card√°pio ou fa√ßa um novo pedido em: cardapio.fortalcar.com" 
            });
            return true;
        }
        
        if (['atendente', 'suporte', 'humano'].includes(lowerMessage)) {
            sock.sendMessage(chatId, { 
                text: "üôã‚Äç‚ôÇÔ∏è *Transferindo para atendimento humano...*\n\nEm breve um de nossos atendentes entrar√° em contato!" 
            });
            return true;
        }
        
        if (['ajuda', 'help'].includes(lowerMessage)) {
            sock.sendMessage(chatId, { 
                text: "‚ÑπÔ∏è *Comandos dispon√≠veis:*\n\n‚Ä¢ *cancelar* - Cancelar pedido\n‚Ä¢ *atendente* - Falar com humano\n‚Ä¢ *menu* - Ver card√°pio" 
            });
            return true;
        }
        
        return false;
    }

    // ETAPA 1: Confirma√ß√£o do pedido (SIM/N√ÉO)
    async handleOrderConfirmation(sock, chatId, message, userPhone, userData) {
        const lowerMessage = message.toLowerCase().trim();
        
        if (['sim', 's', 'confirmar', 'ok', 'confirmo'].includes(lowerMessage)) {
            this.stateManager.setState(userPhone, StateManager.STATES.COLLECTING_NAME);
            
            await sock.sendMessage(chatId, { 
                text: "üë§ *Perfeito! Vamos finalizar seu pedido.*\n\nPara come√ßar, qual seu *nome completo*?" 
            });
            return true;
        }
        
        if (['n√£o', 'nao', 'n', 'cancelar'].includes(lowerMessage)) {
            this.stateManager.resetSession(userPhone);
            await sock.sendMessage(chatId, { 
                text: "‚ùå *Pedido cancelado!*\n\nSem problemas! Acesse nosso card√°pio novamente em:\ncardapio.fortalcar.com" 
            });
            return true;
        }
        
        await sock.sendMessage(chatId, { 
            text: "ü§î N√£o entendi sua resposta.\n\n‚úÖ Digite *SIM* para confirmar o pedido\n‚ùå Digite *N√ÉO* para cancelar" 
        });
        return true;
    }

    // ETAPA 2: Coleta do nome
    async handleNameCollection(sock, chatId, message, userPhone) {
        const validation = ValidationService.validateName(message);
        
        if (validation.valid) {
            this.stateManager.updateData(userPhone, { 
                name: validation.value,
                firstName: validation.firstName 
            });
            this.stateManager.setState(userPhone, StateManager.STATES.COLLECTING_EMAIL);
            
            await sock.sendMessage(chatId, { 
                text: `‚úÖ Nome registrado: *${validation.firstName}*\n\nAgora preciso do seu *e-mail*:` 
            });
            return true;
        }
        
        await sock.sendMessage(chatId, { 
            text: `‚ùå ${validation.error}\n\nPor favor, informe seu *nome completo* (nome e sobrenome):` 
        });
        return true;
    }

    // ETAPA 3: Coleta do email
    async handleEmailCollection(sock, chatId, message, userPhone) {
        const validation = ValidationService.validateEmail(message);
        
        if (validation.valid) {
            this.stateManager.updateData(userPhone, { email: validation.value });
            this.stateManager.setState(userPhone, StateManager.STATES.COLLECTING_ADDRESS);
            
            await sock.sendMessage(chatId, { 
                text: `‚úÖ E-mail registrado: *${validation.value}*\n\nüìç *Agora preciso do endere√ßo de entrega:*\n\nInforme o endere√ßo completo:\n‚Ä¢ Rua e n√∫mero\n‚Ä¢ Bairro\n‚Ä¢ Cidade\n\nExemplo: Rua das Flores, 123, Centro, Fortaleza` 
            });
            return true;
        }
        
        await sock.sendMessage(chatId, { 
            text: `‚ùå ${validation.error}\n\nPor favor, informe um *e-mail v√°lido*:` 
        });
        return true;
    }

    // ETAPA 4: Coleta do endere√ßo
    async handleAddressCollection(sock, chatId, message, userPhone) {
        const validation = ValidationService.validateAddress(message);
        
        if (validation.valid) {
            this.stateManager.updateData(userPhone, { address: validation.value });
            this.stateManager.setState(userPhone, StateManager.STATES.SELECTING_PAYMENT, { 
                paymentStep: 'timing' 
            });
            
            await sock.sendMessage(chatId, { 
                text: `‚úÖ *Endere√ßo confirmado:*\n${validation.value}\n\nüí∞ *Como prefere pagar?*\n\n1Ô∏è‚É£ *Pagar agora* (online)\n2Ô∏è‚É£ *Pagar na entrega*\n\nDigite o *n√∫mero* da op√ß√£o:` 
            });
            return true;
        }
        
        await sock.sendMessage(chatId, { 
            text: `‚ùå ${validation.error}\n\nPor favor, informe o endere√ßo completo:` 
        });
        return true;
    }

    // ETAPA 5: Sele√ß√£o de pagamento
    async handlePaymentSelection(sock, chatId, message, userPhone, userData) {
        const paymentStep = userData.paymentStep || 'timing';
        
        if (paymentStep === 'timing') {
            const validation = ValidationService.validatePaymentTiming(message);
            
            if (validation.valid) {
                this.stateManager.updateData(userPhone, { 
                    paymentTiming: validation.timing,
                    paymentStep: 'method' 
                });
                
                if (validation.timing === 'now') {
                    await sock.sendMessage(chatId, { 
                        text: `‚úÖ *${validation.label}*\n\nüí≥ *Escolha a forma:*\n\n1Ô∏è‚É£ *PIX* (aprova√ß√£o instant√¢nea)\n2Ô∏è‚É£ *Cart√£o de cr√©dito/d√©bito*\n\nDigite o *n√∫mero* da op√ß√£o:` 
                    });
                } else {
                    await sock.sendMessage(chatId, { 
                        text: `‚úÖ *${validation.label}*\n\nüí∞ *Escolha a forma:*\n\n1Ô∏è‚É£ *Cart√£o* (maquininha na entrega)\n2Ô∏è‚É£ *Dinheiro*\n\nDigite o *n√∫mero* da op√ß√£o:` 
                    });
                }
                return true;
            }
            
            await sock.sendMessage(chatId, { 
                text: `‚ùå ${validation.error}` 
            });
            return true;
        }
        
        if (paymentStep === 'method') {
            const paymentTiming = userData.paymentTiming;
            let validation;
            
            if (paymentTiming === 'now') {
                validation = ValidationService.validateOnlinePayment(message);
            } else {
                validation = ValidationService.validateDeliveryPayment(message);
            }
            
            if (validation.valid) {
                this.stateManager.updateData(userPhone, { 
                    paymentMethod: validation.method,
                    paymentLabel: validation.label 
                });
                
                if (validation.method === 'cash') {
                    this.stateManager.updateData(userPhone, { paymentStep: 'change' });
                    
                    const orderData = userData.orderData || {};
                    const total = orderData.total || 0;
                    
                    await sock.sendMessage(chatId, { 
                        text: `‚úÖ *${validation.label}*\n\nüíµ *Precisa de troco?*\n\nTotal do pedido: *R$ ${total.toFixed(2).replace('.', ',')}*\n\nInforme o valor que vai pagar:\n(Digite apenas o valor, ex: 100 ou R$ 100)` 
                    });
                    return true;
                } else {
                    return await this.finalizeOrder(sock, chatId, userPhone);
                }
            }
            
            await sock.sendMessage(chatId, { 
                text: `‚ùå ${validation.error}` 
            });
            return true;
        }
        
        if (paymentStep === 'change') {
            const orderData = userData.orderData || {};
            const total = orderData.total || 0;
            const validation = ValidationService.validateChange(message, total);
            
            if (validation.valid) {
                this.stateManager.updateData(userPhone, { 
                    paymentValue: validation.paymentValue,
                    changeValue: validation.changeValue 
                });
                
                return await this.finalizeOrder(sock, chatId, userPhone);
            }
            
            await sock.sendMessage(chatId, { 
                text: `‚ùå ${validation.error}` 
            });
            return true;
        }
        
        return true;
    }

    // ETAPA 6: Aguardando pagamento
    async handlePaymentWaiting(sock, chatId, message, userPhone, userData) {
        await sock.sendMessage(chatId, { 
            text: "‚è≥ *Aguardando confirma√ß√£o do pagamento...*\n\nAssim que o pagamento for confirmado, seu pedido entrar√° na fila de preparo!\n\nDigite *status* para acompanhar." 
        });
        return true;
    }

    // Finalizar pedido
    async finalizeOrder(sock, chatId, userPhone) {
        const userData = this.stateManager.getUserData(userPhone);
        const orderData = userData.orderData || {};
        
        this.stateManager.setState(userPhone, StateManager.STATES.ORDER_COMPLETED);
        
        // ‚úÖ SALVAR PEDIDO NO BACKEND
try {
  const api = require('../services/api');
  const pedidoData = {
    customerName: userData.name,
    customerPhone: userPhone,
    customerAddress: userData.address,
    items: orderData.items,
    total: orderData.total,
    paymentMethod: userData.paymentLabel || 'whatsapp'
  };
  
  console.log('Salvando pedido no backend:', pedidoData);
  const response = await api.createOrder(pedidoData);
  console.log('Pedido salvo com sucesso:', response.data);
} catch (error) {
  console.error('Erro ao salvar pedido:', error);
}
        let finalMessage = "üéâ *PEDIDO CONFIRMADO!*\n\n";
        finalMessage += "üìã *Resumo final:*\n";
        
        // Itens do pedido
        if (orderData.items) {
            orderData.items.forEach(item => {
                finalMessage += `‚Ä¢ ${item.quantity}x ${item.name} - R$ ${item.total.toFixed(2).replace('.', ',')}\n`;
            });
        }
        
        finalMessage += `\nüí∞ *Total: R$ ${orderData.total ? orderData.total.toFixed(2).replace('.', ',') : '0,00'}*\n`;
        finalMessage += `üë§ *Cliente:* ${userData.name}\n`;
        finalMessage += `üìß *E-mail:* ${userData.email}\n`;
        finalMessage += `üìç *Endere√ßo:* ${userData.address}\n`;
        finalMessage += `üí≥ *Pagamento:* ${userData.paymentLabel}`;
        
        if (userData.changeValue && userData.changeValue > 0) {
            finalMessage += `\nüíµ *Troco para:* R$ ${userData.paymentValue.toFixed(2).replace('.', ',')}`;
            finalMessage += `\nüí∞ *Troco:* R$ ${userData.changeValue.toFixed(2).replace('.', ',')}`;
        }
        
        finalMessage += "\n\nüïê *Tempo estimado:* 30-45 minutos";
        finalMessage += "\nüì± *Acompanhe:* Digite *status* a qualquer momento";
        
        await sock.sendMessage(chatId, { text: finalMessage });
        
        // Limpar sess√£o ap√≥s 5 minutos
        setTimeout(() => {
            this.stateManager.resetSession(userPhone);
        }, 5 * 60 * 1000);
        
        return true;
    }

    // Verifica se usu√°rio est√° em fluxo ativo
    isUserInFlow(userPhone) {
        return this.stateManager.isInActiveFlow(userPhone);
    }

    // Inicia fluxo com dados do pedido do card√°pio
    startFlowWithOrder(userPhone, orderData) {
        this.stateManager.setState(userPhone, StateManager.STATES.CONFIRMING_ORDER);  
          orderData: orderData
}

