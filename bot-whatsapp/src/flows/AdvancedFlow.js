// src/flows/advancedFlow.js
// Fluxo Avan√ßado Completo para Processamento de Pedidos

const StateManager = require('../services/StateManager');
const ValidationService = require('../services/ValidationService');

class AdvancedFlow {
    constructor() {
        this.stateManager = new StateManager();
        
        console.log('[AdvancedFlow] Iniciado com sucesso');
    }

    // Processa mensagem baseada no estado atual do usu√°rio
    async processMessage(sock, chatId, message, userPhone) {
        try {
            const currentState = this.stateManager.getState(userPhone);
            const userData = this.stateManager.getUserData(userPhone);
            
            console.log(`[AdvancedFlow] ${userPhone} | Estado: ${currentState} | Mensagem: ${message.substring(0, 30)}`);

            // Comandos globais (funcionam em qualquer estado)
            if (this.handleGlobalCommands(sock, chatId, message, userPhone)) {
                return true;
            }

            // Processar baseado no estado atual
            switch (currentState) {
                case StateManager.STATES.CONFIRMING_CUSTOMER_DATA:
                    return await this.handleCustomerDataConfirmation(sock, chatId, message, userPhone, userData);
                  
                case StateManager.STATES.CONFIRMING_ORDER:
                    return await this.handleOrderConfirmation(sock, chatId, message, userPhone, userData);
                
                case StateManager.STATES.COLLECTING_NAME:
                    return await this.handleNameCollection(sock, chatId, message, userPhone);
                
                case StateManager.STATES.COLLECTING_STREET:
                    return await this.handleStreetCollection(sock, chatId, message, userPhone);
                
                case StateManager.STATES.COLLECTING_NUMBER:
                    return await this.handleNumberCollection(sock, chatId, message, userPhone);
                
                case StateManager.STATES.COLLECTING_OBSERVATIONS:
                    return await this.handleObservationsCollection(sock, chatId, message, userPhone);
                
                case StateManager.STATES.SELECTING_PAYMENT:
                    return await this.handlePaymentSelection(sock, chatId, message, userPhone, userData);
                
                case StateManager.STATES.WAITING_PAYMENT:
                    return await this.handlePaymentWaiting(sock, chatId, message, userPhone, userData);
                
                default:
                    return false; // N√£o est√° em fluxo ativo
            }

        } catch (error) {
            console.error('[AdvancedFlow] Erro:', error);
            await sock.sendMessage(chatId, { 
                text: "‚ùå Ocorreu um erro. Digite *cancelar* para recome√ßar." 
            });
            return true;
        }
    }

    // Comandos globais (cancelar, ajuda, voltar)
    handleGlobalCommands(sock, chatId, message, userPhone) {
        const lowerMessage = message.toLowerCase().trim();
        
        if (['cancelar', 'cancel', 'sair', 'pare', 'parar'].includes(lowerMessage)) {
            this.stateManager.resetSession(userPhone);
            sock.sendMessage(chatId, { 
                text: "‚ùå *Pedido cancelado!*\n\nDigite *menu* para ver nosso card√°pio ou fa√ßa um novo pedido em: cardapio.fortalcar.com" 
            });
            return true;
        }
        
        if (['atendente', 'suporte', 'humano'].includes(lowerMessage)) {
            sock.sendMessage(chatId, { 
                text: "üôã‚Äç‚ôÇÔ∏è *Transferindo para atendimento humano...*\n\nEm breve um de nossos atendentes entrar√° em contato!" 
            });
            return true;
        }
        
        if (['ajuda', 'help'].includes(lowerMessage)) {
            sock.sendMessage(chatId, { 
                text: "‚ÑπÔ∏è *Comandos dispon√≠veis:*\n\n‚Ä¢ *cancelar* - Cancelar pedido\n‚Ä¢ *voltar* - Voltar etapa anterior\n‚Ä¢ *atendente* - Falar com humano\n‚Ä¢ *menu* - Ver card√°pio" 
            });
            return true;
        }
        
        if (['voltar', 'volta', 'anterior'].includes(lowerMessage)) {
            return this.handleGoBack(sock, chatId, userPhone);
        }
        
        return false;
    }

    // Fun√ß√£o para voltar √† etapa anterior
    async handleGoBack(sock, chatId, userPhone) {
        const currentState = this.stateManager.getState(userPhone);
        
        switch (currentState) {
            case StateManager.STATES.COLLECTING_NAME:
                this.stateManager.setState(userPhone, StateManager.STATES.CONFIRMING_ORDER);
                await sock.sendMessage(chatId, { 
                    text: "‚¨ÖÔ∏è *Voltando...*\n\n‚úÖ Digite *SIM* para confirmar seu pedido\n‚ùå Digite *N√ÉO* para cancelar" 
                });
                return true;
                
            case StateManager.STATES.COLLECTING_STREET:
                this.stateManager.setState(userPhone, StateManager.STATES.COLLECTING_NAME);
                await sock.sendMessage(chatId, { 
                    text: "‚¨ÖÔ∏è *Voltando...*\n\nüë§ Qual seu *nome completo*?" 
                });
                return true;
                
            case StateManager.STATES.COLLECTING_NUMBER:
                this.stateManager.setState(userPhone, StateManager.STATES.COLLECTING_STREET);
                await sock.sendMessage(chatId, { 
                    text: "‚¨ÖÔ∏è *Voltando...*\n\nüè† Informe o nome da *RUA* para entrega:\n\nExemplo: Rua das Flores" 
                });
                return true;
                
            case StateManager.STATES.COLLECTING_OBSERVATIONS:
                this.stateManager.setState(userPhone, StateManager.STATES.COLLECTING_NUMBER);
                await sock.sendMessage(chatId, { 
                    text: "‚¨ÖÔ∏è *Voltando...*\n\nüè† Agora informe o *N√öMERO* da casa e *COMPLEMENTO* (se houver):\n\nExemplo: 123, Apt 45" 
                });
                return true;
                
            case StateManager.STATES.SELECTING_PAYMENT:
                this.stateManager.setState(userPhone, StateManager.STATES.COLLECTING_OBSERVATIONS);
                await sock.sendMessage(chatId, { 
                    text: "‚¨ÖÔ∏è *Voltando...*\n\nüìù *Alguma observa√ß√£o sobre seu pedido?*\n\nExemplo: Sem cebola, massa fininha\n\nOu digite *pular* se n√£o tiver observa√ß√µes:" 
                });
                return true;
                
            default:
                await sock.sendMessage(chatId, { 
                    text: "‚ùå N√£o √© poss√≠vel voltar desta etapa.\n\nDigite *cancelar* para recome√ßar." 
                });
                return true;
        }
    }

    // ETAPA 1: Confirma√ß√£o do pedido (SIM/N√ÉO)
    async handleOrderConfirmation(sock, chatId, message, userPhone, userData) {
        const lowerMessage = message.toLowerCase().trim();
        
        if (['sim', 's', 'confirmar', 'ok', 'confirmo'].includes(lowerMessage)) {
            this.stateManager.setState(userPhone, StateManager.STATES.COLLECTING_NAME);
            
            await sock.sendMessage(chatId, { 
                text: "üéâ *Que alegria! Vamos finalizar seu delicioso pedido!* üòã\n\nüë§ Para come√ßar, me conta qual seu *nome completo*?\n\nFico feliz em te atender! ü§ó\n\nüí° Digite *voltar* para etapa anterior" 
            });
            return true;
        }
        
        if (['n√£o', 'nao', 'n', 'cancelar'].includes(lowerMessage)) {
            this.stateManager.resetSession(userPhone);
            await sock.sendMessage(chatId, { 
                text: "‚ùå *Pedido cancelado!*\n\nSem problemas! Acesse nosso card√°pio novamente em:\ncardapio.fortalcar.com" 
            });
            return true;
        }
        
        await sock.sendMessage(chatId, { 
            text: "ü§î N√£o entendi sua resposta.\n\n‚úÖ Digite *SIM* para confirmar o pedido\n‚ùå Digite *N√ÉO* para cancelar" 
        });
        return true;
    }

    // ETAPA 2: Coleta do nome
    async handleNameCollection(sock, chatId, message, userPhone) {
        const validation = ValidationService.validateName(message);
        
        if (validation.valid) {
            this.stateManager.updateData(userPhone, { 
                name: validation.value,
                firstName: validation.firstName 
            });
            this.stateManager.setState(userPhone, StateManager.STATES.COLLECTING_STREET);
            
            await sock.sendMessage(chatId, { 
                text: `‚úÖ Prazer em conhecer voc√™, *${validation.firstName}*! üòä\n\nüè† Agora me conta, qual o nome da *RUA* onde vamos entregar seu pedido?\n\nExemplo: Rua das Flores\n\nüí° Digite *voltar* para etapa anterior` 
            });
            return true;
        }
        
        await sock.sendMessage(chatId, { 
            text: `‚ùå ${validation.error}\n\nPor favor, informe seu *nome completo* (nome e sobrenome):\n\nüí° Digite *voltar* para voltar` 
        });
        return true;
    }

    // ETAPA 3: Coleta da rua
    async handleStreetCollection(sock, chatId, message, userPhone) {
        const validation = ValidationService.validateStreet(message);
        
        if (validation.valid) {
            this.stateManager.updateData(userPhone, { street: validation.value });
            this.stateManager.setState(userPhone, StateManager.STATES.COLLECTING_NUMBER);
            
            await sock.sendMessage(chatId, { 
                text: `‚úÖ √ìtimo! Rua anotada: *${validation.value}* üìç\n\nüè† Agora me fala o *N√öMERO* da sua casa e o *COMPLEMENTO* (se tiver):\n\nExemplo: 123, Apt 45\n\nEstamos quase l√°! üòâ\n\nüí° Digite *voltar* para etapa anterior` 
            });
            return true;
        }
        
        await sock.sendMessage(chatId, { 
            text: `‚ùå ${validation.error}\n\nPor favor, informe o nome da rua:\n\nüí° Digite *voltar* para voltar` 
        });
        return true;
    }

    // ETAPA 4: Coleta do n√∫mero e complemento
    async handleNumberCollection(sock, chatId, message, userPhone) {
        const validation = ValidationService.validateNumber(message);
        
        if (validation.valid) {
            this.stateManager.updateData(userPhone, { 
                number: validation.value,
                fullAddress: `${this.stateManager.getUserData(userPhone).street}, ${validation.value}`
            });
            this.stateManager.setState(userPhone, StateManager.STATES.COLLECTING_OBSERVATIONS);
            
            await sock.sendMessage(chatId, { 
                text: `‚úÖ Perfeito! Endere√ßo anotado: *${this.stateManager.getUserData(userPhone).fullAddress}* üéØ\n\nüìù *Quer fazer alguma observa√ß√£o especial sobre seu pedido?* üçï\n\nExemplo: Sem cebola, massa fininha, bem assadinha\n\nOu digite *pular* se estiver tudo perfeito do jeito que est√°! üòã\n\nüí° Digite *voltar* para etapa anterior` 
            });
            return true;
        }
        
        await sock.sendMessage(chatId, { 
            text: `‚ùå ${validation.error}\n\nPor favor, informe o n√∫mero da casa e complemento:\n\nüí° Digite *voltar* para voltar` 
        });
        return true;
    }

    // ETAPA 5: Coleta das observa√ß√µes
    async handleObservationsCollection(sock, chatId, message, userPhone) {
        const lowerMessage = message.toLowerCase().trim();
        
        if (['pular', 'nao', 'n√£o', 'sem observa√ß√£o', 'sem observacoes'].includes(lowerMessage)) {
            this.stateManager.updateData(userPhone, { observations: '' });
        } else {
            this.stateManager.updateData(userPhone, { observations: message.trim() });
        }
        
        this.stateManager.setState(userPhone, StateManager.STATES.SELECTING_PAYMENT, { 
            paymentStep: 'timing' 
        });
        
        const obsText = this.stateManager.getUserData(userPhone).observations;
        const confirmObs = obsText ? `‚úÖ *Observa√ß√µes:* ${obsText}` : ' *Sem observa√ß√µes*';
        
        await sock.sendMessage(chatId, { 
            text: `${confirmObs}\n\nüí∞ *Agora vamos para o pagamento! Como voc√™ prefere pagar?* üòä\n\n1Ô∏è‚É£ *Pagar agora* (r√°pido e pr√°tico! üí≥)\n2Ô∏è‚É£ *Pagar na entrega* (tranquilidade total! üöö)\n\nDigite o *n√∫mero* da sua prefer√™ncia:\n\nüí° Digite *voltar* para etapa anterior` 
        });
        return true;
    }

    // ETAPA 6: Sele√ß√£o de pagamento
    async handlePaymentSelection(sock, chatId, message, userPhone, userData) {
        const paymentStep = userData.paymentStep || 'timing';
        
        if (paymentStep === 'timing') {
            const validation = ValidationService.validatePaymentTiming(message);
            
            if (validation.valid) {
                this.stateManager.updateData(userPhone, { 
                    paymentTiming: validation.timing,
                    paymentStep: 'method' 
                });
                
                if (validation.timing === 'now') {
                    await sock.sendMessage(chatId, { 
                        text: `‚úÖ *${validation.label}*\n\nüí≥ *Escolha a forma:*\n\n1Ô∏è‚É£ *PIX* (aprova√ß√£o instant√¢nea)\n2Ô∏è‚É£ *Cart√£o de cr√©dito/d√©bito*\n\nDigite o *n√∫mero* da op√ß√£o:\n\nüí° Digite *voltar* para etapa anterior` 
                    });
                } else {
                    await sock.sendMessage(chatId, { 
                        text: `‚úÖ *${validation.label}*\n\nüí∞ *Escolha a forma:*\n\n1Ô∏è‚É£ *Cart√£o* (maquininha na entrega)\n2Ô∏è‚É£ *Dinheiro*\n\nDigite o *n√∫mero* da op√ß√£o:\n\nüí° Digite *voltar* para etapa anterior` 
                    });
                }
                return true;
            }
            
            await sock.sendMessage(chatId, { 
                text: `‚ùå ${validation.error}\n\nüí° Digite *voltar* para voltar` 
            });
            return true;
        }
        
        if (paymentStep === 'method') {
            const paymentTiming = userData.paymentTiming;
            let validation;
            
            if (paymentTiming === 'now') {
                validation = ValidationService.validateOnlinePayment(message);
            } else {
                validation = ValidationService.validateDeliveryPayment(message);
            }
            
            if (validation.valid) {
                this.stateManager.updateData(userPhone, { 
                    paymentMethod: validation.method,
                    paymentLabel: validation.label 
                });
                
                if (validation.method === 'cash') {
                    this.stateManager.updateData(userPhone, { paymentStep: 'change' });
                    
                    const orderData = userData.orderData || {};
                    const total = orderData.total || 0;
                    
                    await sock.sendMessage(chatId, { 
                        text: `‚úÖ *${validation.label}*\n\nüíµ *Precisa de troco?*\n\nTotal do pedido: *R$ ${total.toFixed(2).replace('.', ',')}*\n\nInforme o valor que vai pagar:\n(Digite apenas o valor, ex: 100 ou R$ 100)\n\nüí° Digite *voltar* para voltar` 
                    });
                    return true;
                } else {
                    return await this.finalizeOrder(sock, chatId, userPhone);
                }
            }
            
            await sock.sendMessage(chatId, { 
                text: `‚ùå ${validation.error}\n\nüí° Digite *voltar* para voltar` 
            });
            return true;
        }
        
        if (paymentStep === 'change') {
            const orderData = userData.orderData || {};
            const total = orderData.total || 0;
            const validation = ValidationService.validateChange(message, total);
            
            if (validation.valid) {
                this.stateManager.updateData(userPhone, { 
                    paymentValue: validation.paymentValue,
                    changeValue: validation.changeValue 
                });
                
                return await this.finalizeOrder(sock, chatId, userPhone);
            }
            
            await sock.sendMessage(chatId, { 
                text: `‚ùå ${validation.error}\n\nüí° Digite *voltar* para voltar` 
            });
            return true;
        }
        
        return true;
    }

    // ETAPA 7: Aguardando pagamento
    async handlePaymentWaiting(sock, chatId, message, userPhone, userData) {
        await sock.sendMessage(chatId, { 
            text: "‚è≥ *Aguardando confirma√ß√£o do pagamento...*\n\nAssim que o pagamento for confirmado, seu pedido entrar√° na fila de preparo!\n\nDigite *status* para acompanhar." 
        });
        return true;
    }

    // Finalizar pedido
    async finalizeOrder(sock, chatId, userPhone) {
        const userData = this.stateManager.getUserData(userPhone);
        const orderData = userData.orderData || {};
        
        this.stateManager.setState(userPhone, StateManager.STATES.ORDER_COMPLETED);
        
        // ‚úÖ SALVAR PEDIDO NO BACKEND
        try {
            const api = require('../services/api');
            const pedidoData = {
                customerName: userData.name,
                customerPhone: userPhone,
                customerAddress: userData.fullAddress,
                observations: userData.observations || '',
                items: orderData.items,
                total: orderData.total,
                paymentMethod: userData.paymentLabel || 'whatsapp'
            };
            
            console.log('Salvando pedido no backend:', pedidoData);
            const response = await api.createOrder(pedidoData);
            console.log('Pedido salvo com sucesso:', response.data);
        } catch (error) {
            console.error('Erro ao salvar pedido:', error);
        }
        
        let finalMessage = "üéâ *UHUL! SEU PEDIDO FOI CONFIRMADO COM SUCESSO!* üçï‚ú®\n\nObrigado pela confian√ßa! Estamos preparando tudo com muito carinho para voc√™! üòã‚ù§Ô∏è\n\n";
        finalMessage += "üìã *Resumo final:*\n";
        
        // Itens do pedido
        if (orderData.items) {
            orderData.items.forEach(item => {
                finalMessage += `‚Ä¢ ${item.quantity}x ${item.name} - R$ ${item.total.toFixed(2).replace('.', ',')}\n`;
            });
        }
        
        finalMessage += `\nüí∞ *Total: R$ ${orderData.total ? orderData.total.toFixed(2).replace('.', ',') : '0,00'}*\n`;
        finalMessage += `üë§ *Cliente:* ${userData.name}\n`;
        finalMessage += `üìç *Endere√ßo:* ${userData.fullAddress}\n`;
        
        if (userData.observations) {
            finalMessage += `üìù *Observa√ß√µes:* ${userData.observations}\n`;
        }
        
        finalMessage += `üí≥ *Pagamento:* ${userData.paymentLabel}`;
        
        // Calcular tempo estimado baseado no dia da semana
        const today = new Date();
        const dayOfWeek = today.getDay(); // 0=Domingo, 1=Segunda, 2=Ter√ßa, etc.

        let estimatedTime;
        if (dayOfWeek >= 1 && dayOfWeek <= 4) { // Segunda a Quinta (1-4)
            estimatedTime = "30-45 minutos";
        } else { // Sexta, S√°bado e Domingo (5, 6, 0)
            estimatedTime = "45-60 minutos";
        }

        finalMessage += `\n\nüïê *Tempo estimado:* ${estimatedTime}`;
        
        if (userData.changeValue && userData.changeValue > 0) {
            finalMessage += `\nüíµ *Troco para:* R$ ${userData.paymentValue.toFixed(2).replace('.', ',')}`;
            finalMessage += `\nüí∞ *Troco:* R$ ${userData.changeValue.toFixed(2).replace('.', ',')}`;
        }
        
        await sock.sendMessage(chatId, { text: finalMessage });
        
        // Limpar sess√£o ap√≥s 5 minutos
        setTimeout(() => {
            this.stateManager.resetSession(userPhone);
        }, 5 * 60 * 1000);
        
        return true;
    }

    // Verifica se usu√°rio est√° em fluxo ativo
    isUserInFlow(userPhone) {
        return this.stateManager.isInActiveFlow(userPhone);
    }

    // Inicia fluxo com dados do pedido do card√°pio
    startFlowWithOrder(userPhone, orderData) {
        this.stateManager.setState(userPhone, StateManager.STATES.CONFIRMING_ORDER);
        this.stateManager.updateData(userPhone, { 
            orderData: orderData 
        });
    }

    // Inicia fluxo direto (sem dados de pedido)
    startDirectOrder(userPhone) {
        this.stateManager.setState(userPhone, StateManager.STATES.COLLECTING_NAME);
        this.stateManager.updateData(userPhone, { 
            orderData: { items: [], total: 0, source: 'direct_whatsapp' }
        });
    }

    // üÜï NOVA FUN√á√ÉO: Confirmar dados do cliente existente
    async handleCustomerDataConfirmation(sock, chatId, message, userPhone, userData) {
        const lowerMessage = message.toLowerCase().trim();
        
        if (['sim', 's', 'confirmar', 'ok', 'confirmo'].includes(lowerMessage)) {
            // Cliente confirmou - pular para observa√ß√µes
           const expressData = userData.expressData || {};
           this.stateManager.updateData(userPhone, {
               name: expressData.name,
               fullAddress: expressData.address,
               firstName: expressData.name ? expressData.name.split(' ')[0] : ''
             });
            this.stateManager.setState(userPhone, StateManager.STATES.COLLECTING_OBSERVATIONS);
            
            await sock.sendMessage(chatId, { 
                text: "üéâ *Perfeito! Dados confirmados!* ‚úÖ\n\nüìù *Quer fazer alguma observa√ß√£o especial sobre seu pedido?* üçï\n\nExemplo: Sem cebola, massa fininha, bem assadinha\n\nOu digite *pular* se estiver tudo perfeito do jeito que est√°! üòã\n\nüí° Digite *voltar* para etapa anterior" 
            });
            return true;
        }
        
        if (['n√£o', 'nao', 'n', 'alterar', 'mudar'].includes(lowerMessage)) {
            // Cliente quer alterar - ir para fluxo normal
            this.stateManager.setState(userPhone, StateManager.STATES.COLLECTING_NAME);
            
            await sock.sendMessage(chatId, { 
                text: "üìù *Sem problemas! Vamos atualizar seus dados.*\n\nüë§ Qual seu *nome completo*?\n\nüí° Digite *voltar* para etapa anterior" 
            });
            return true;
        }
        
        await sock.sendMessage(chatId, { 
            text: "ü§î N√£o entendi sua resposta.\n\n‚úÖ Digite *SIM* para confirmar os dados\nüìù Digite *N√ÉO* para alterar" 
        });
        return true;
    }

    // üÜï NOVA FUN√á√ÉO: Iniciar fluxo expresso
    startExpressFlow(userPhone, customerData) {
        this.stateManager.setState(userPhone, StateManager.STATES.CONFIRMING_CUSTOMER_DATA);
        this.stateManager.updateData(userPhone, { 
            expressData: customerData,
            orderData: { items: [], total: 0, source: 'direct_whatsapp' }
        });
    }

    // üÜï NOVA FUN√á√ÉO: Iniciar fluxo expresso COM dados do pedido
    startExpressFlowWithOrder(userPhone, customerData, orderData) {
        this.stateManager.setState(userPhone, StateManager.STATES.CONFIRMING_CUSTOMER_DATA);
        this.stateManager.updateData(userPhone, { 
            expressData: customerData,
            orderData: orderData
        });
    }

}

module.exports = AdvancedFlow;
